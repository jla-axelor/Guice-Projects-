/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package Guice_three;


import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import com.google.inject.AbstractModule;
import com.google.inject.BindingAnnotation;
import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.name.Named;
import com.google.inject.name.Names;



import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.METHOD;


//for binding annotation we created annotation class with these 3 annotation

@BindingAnnotation @Target({ FIELD, PARAMETER, METHOD }) @Retention(RUNTIME)
@interface WinWord {}
@BindingAnnotation @Target({ FIELD, PARAMETER, METHOD }) @Retention(RUNTIME)
@interface JDBC {}


//This is our main class 
class App {
    public static void main(String[] args) {
    	//create Injector for TextEditorModule() ->in which our all binding is present
     	 Injector injector = Guice.createInjector(new TextEditorModule());
         TextEditor editor = injector.getInstance(TextEditor.class);
         //for calling makeSpellCheck() -> it will go to the TextEditor class
         editor.makeSpellCheck();
    }   
}

// App --->  TextEditor


class TextEditor {
	   private SpellChecker spellChecker; 
	   private String url;
	   //here our inject annotation is present with annotation @WinWord so it will go to the TextEditorModule to see that
	   // any binding present for @WinWord SpellChecker 
	   @Inject
	   public TextEditor(@WinWord SpellChecker spellChecker , @JDBC String url) {
	      this.spellChecker = spellChecker;
	      this.url = url;
	   }

	   public void makeSpellCheck(){
	      spellChecker.checkSpelling();
	      System.out.println(url);
	   } 
	}

	//SpellChecker --> TextEditorModule


class TextEditorModule extends AbstractModule {

	   @Override
	   protected void configure() {
		   //here we gave binding with annoted class WinWord and target is WinWordSpellCheckerImpl class
		   
		   //we can also use annotation binding without creating annotation class
		   // so the binding is :
		   //    bind(SpellChecker.class).annotatedWith(Names.named("WinWord")).to(WinWordSpellCheckerImpl.class);
		   
	      bind(SpellChecker.class).annotatedWith(WinWord.class)
	         .to(WinWordSpellCheckerImpl.class);
	      
	      //for binding constant 
	      bind(String.class).annotatedWith(JDBC.class).toInstance("jdbc:postgresql://localhost:5500/myDb");
	   } 
	}

// TextEditorModule --> SpellChecker --> with this annotation --> WinWordSpellCheckerImpl


interface SpellChecker {
	   public void checkSpelling();
	}

	//spell checker implementation
	class SpellCheckerImpl implements SpellChecker {

	   @Override
	   public void checkSpelling() {
	      System.out.println("Inside checkSpelling." );
	   } 
	}

	//from here it will take checkSpelling method and give to the textEditor method
	//subclass of SpellCheckerImpl
	class WinWordSpellCheckerImpl extends SpellCheckerImpl{
	   @Override
	   public void checkSpelling() {
	      System.out.println("Inside WinWordSpellCheckerImpl.checkSpelling." );
	   } 
	}
	
// WinWordSpellCheckerImpl --> textEditor --> App 

//OUTPUT is :
	// Inside WinWordSpellCheckerImpl.checkSpelling.